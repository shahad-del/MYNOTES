{% extends 'basis.html' %}
{% block title %}
<title>ConnectingToDatabase</title>
{% endblock %}
{% block body %}
<h3>Connecting to postgres database</h3>
<p class = "descText"><pre><code lang="python">
    import psycopg2
    db_host = 'localhost'
    db_name = 'quiz'
    db_user = 'postgres'
    db_pass = 'password'
    conn = psycopg2.connect(dbname= db_name, user=db_user, password=db_pass,host=db_host)
    cur = conn.cursor()
    cur.execute(""" select question  as easy from questions inner join category on  category.s_no = questions.category_id where category_id = 1;
     """)
    cur.execute(""" select question  as easy,STRING_AGG(options_in_points,',') from questions inner join category on  category.s_no = questions.category_id 
    inner join multiple_choices on questions.q_no = multiple_choices.question_id where category_id = 1 Group by question;
    """)
    query = cur.fetchall()
    print(query)
    cur.close()
    conn.close 
</code></pre></p>
<p class = "descText">When we want to include variable in a query:
<pre><code lang='python'>
    @app.route('/questions',methods = ['POST'])
    def questions() -> 'html':
    
        selectedLevel = request.form.get('difficulty_level')
    
    
        submittedAnswers = request.form.getlist('choices')
    
        conn = psycopg2.connect(dbname= db_name, user=db_user, password=db_pass,host=db_host)
        cur = conn.cursor()
        questionWithChoicesQuery = """
        select
            q.q_no as question_id, 
            q.question  as QuestionText,
            c.options_in_points as choice,
            c.id as choice_id
        from questions q
        inner join category on 
            category.s_no = q.category_id 
        inner join multiple_choices c on 
            q.q_no = c.question_id 
        where 
            category_id = %(levelId)s;"""
    
        cur.execute(questionWithChoicesQuery, {'levelId': selectedLevel})
        questionList = cur.fetchall()
        structuredData = reformat_data(questionList)
        return render_template('questions.html',questions = structuredData)   
</code></pre>    
</p>
<p class = "descText">
    When we want to edit the data collected from user input,it is must that we keep our button type to submit and wrap it in a form tag.In form tag we have to include action that determines where we want our collected data to be submitted.Method needs to be POST if we want to update,edit those data.
<pre><code lang ="sql">
    {%raw %}
      <form action="/questions" method="post">
        <label for="difficulty_level">Choose the difficulty level</label>
        <select id="difficulty_level" name="difficulty_level">
          {% for c in categories %}
          <option value="{{c[0]}}" id="{{c[0]}}">{{c[1]}}</option>   
          {% endfor %}
        </select>
        <button class="app-button" type="submit">Begin Quiz</button>
      </form>
    {%endraw%}
</code></pre>
</p>
<h3>creating and downloading dummy data through mockaroo</h3>
<video width="420" height="340" controls>
    <source src="/static/videos/mockaroo_data.mkv" type="video/mp4">
    Your browser does not support the video tag.
</video>
<h3>connecting through mysql connector</h3>
<p class = "descText"><pre><code lang="python"></code>
	import mysql.connector
	dbconfig = {
		'host': '127.0.0.1',
		'database': 'bucket_list',
		'user': 'root',
		'password': 'mysqlroot'
	}
	def insert_sql(dataToInsert):
		conn = mysql.connector.connect(**dbconfig)
		cursor = conn.cursor()
		_sql = 'INSERT INTO list(items)values(%s)'
		cursor.execute(_sql,dataToInsert)
		conn.commit()
		cursor.close()
		conn.close()
	def getAll():
		conn = mysql.connector.connect(**dbconfig)
		cursor = conn.cursor()
		_sql = 'SELECT * FROM list ORDER BY id DESC'
		cursor.execute(_sql)
		records = cursor.fetchall()
		cursor.close
		return records
	def edit_data(data_to_edit,updated_info):
		conn = mysql.connector.connect(**dbconfig)
		cursor = conn.cursor()
		_sql = 'UPDATE list SET items = %s  where items = %s'
		val = (updated_info,data_to_edit)
		cursor.execute(_sql,val)
		conn.commit()
		cursor.close()
		conn.close()
	def delete_data(item_to_delete):
		conn = mysql.connector.connect(**dbconfig)
		cursor = conn.cursor()
		_sql = 'DELETE FROM list WHERE items = %s'
		cursor.execute(_sql,item_to_delete)
		conn.commit()
		cursor.close()
		conn.close()
</pre></p>

<h3>creating virtual environment and activating it. .Venv is the name of the folder.We can name it whatever we want. last command creates Requirements.txt file and store whatever library we need for the certain project. </h3>
<p class = "descText"><pre><code lang="python"></code>
	python3 -m venv .venv
	source .venv/bin/activate
	pip3 freeze > requirements.txt
</pre></p>

<h3>
	configuration for starting rest API
</h3>
<p class = "descText"><pre><code lang="python"></code>
from flask import Flask,request
from flask_sqlalchemy import SQLAlchemy
from SQLAlchemy.sql import func
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI']='sqlite:///data.db'
db = SQLAlchemy(app)

class Drinks(db.Model):
	
		id = db.Column(db.Integer, primary_key=True)
		name = db.Column(db.String(80),unique=True,nullable=False)
		description = db.Column(db.String(120))
		time_created = Column(DateTime(timezone=True), server_default=func.now())
		time_updated = Column(DateTime(timezone=True), onupdate=func.now())

		def __repr__(self):
			return f"{self.name} - {self.description}"
</pre></p>

<h3>Now  to create database,inserting into it,querying into database.</h3>
<p class = "descText"><pre><code lang="python"></code>
	If any error occurs type [app.app_context().push()] after importing
	from app import db,app,Drinks
	db.create_all()
	d = Drinks(name='grape',description='tastes sweet')
	db.session.add(d)
	db.session.commit()
	TO QUERY about our database
	Drink.query.all()
	</pre></p>
<h3>To fetch data with python code using database created through API.</h3>
<p class = "descText"><pre><code lang="python"></code>
	@app.route('/drinks')
	def get_drinks():
	drinks = Drinks.query.all()
	output = []
	for drink in drinks:
		drink_data = {'name': drink.name, 'description': drink.description}
		output.append(drink_data)
	return{"drinks":output}


	def get_drink(id):
	drink=Drinks.query.get_or_404(id)
	return{"name":drink.name, "description":drink.description}
	</pre></p>

<h3>
	pip install -r requirements.txt.This command will install all the files in requirements.txt folder.
</h3>	
<p class = "descText"><pre><code lang="python"></code>
click==7.1.2
Flask==1.1.2
Flask-RESTful==0.3.8
Flask-SQLAlchemy==2.4.3
itsdangerous==1.1.0
Jinja2==2.11.2
MarkupSafe==1.1.1
pytz==2020.1
six==1.15.0
SQLAlchemy==1.3.18
Werkzeug==1.0.1
{% endblock %}
</pre></p>